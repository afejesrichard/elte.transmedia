<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>The Beast Map with Popper</title>
  <style>
    body { font-family: Arial; margin: 0; }
    #cy { width: 100%; height: 95vh; display: block; }
    #controls {
      padding: 10px;
      background: #f8f8f8;
      border-bottom: 1px solid #ccc;
    }
    .legend, .btn {
      margin-right: 10px;
    }
    .popper-box {
      background: rgba(255, 255, 150, 0.3);
      border: 1px dashed #999;
      border-radius: 10px;
      padding: 2px 5px;
      font-size: 14px;
      pointer-events: none;
    }
  </style>
  <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/@popperjs/core@2/dist/umd/popper.min.js"></script>
  <script src="https://unpkg.com/cytoscape-popper/cytoscape-popper.js"></script>
</head>
<body>
  <div id="controls">
    <button class="btn" onclick="cy.fit()">Recenter View</button>
    <span class="legend" id="legend"></span>
  </div>
  <div id="cy"></div>

  <script>
    const colors = {
      "Email": "#FF00FF",
      "Event": "#FF0000",
      "Object": "#999999",
      "Photo": "#FF6666",
      "Post": "#FFFF00",
      "Puzzle": "#FF6600",
      "Sound": "#00FFCC",
      "Video": "#00FF00",
      "Webpage": "#3333FF",
      "Other": "#CCCCCC"
    };

    const sizeScale = (val, min = 50, max = 500) => {
      const clamped = Math.min(1, Math.max(0, val / 1000));
      return min + clamped * (max - min);
    };

    const fontScale = (val, min = 30, max = 60) => {
      const clamped = Math.min(1, Math.max(0, val / 1000));
      return min + clamped * (max - min);
    };

    fetch('The_Beast_transmedia_map.cyjs')
      .then(res => res.json())
      .then(data => {
        const elements = {
          nodes: data.elements.nodes
            .filter(n => n.data.owner !== "FAN")
            .map(n => ({
              data: {
                id: n.data.id,
                label: n.data.Label || n.data.id,
                type: n.data.type || "Other",
                centrality: n.data.BetweennessCentrality || 0
              },
              position: n.position
            })),
          edges: data.elements.edges.filter(e =>
            data.elements.nodes.some(n => n.data.id === e.data.source) &&
            data.elements.nodes.some(n => n.data.id === e.data.target)
          )
        };

        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements,
          style: [
            {
              selector: 'node',
              style: {
                'background-color': ele => colors[ele.data('type')] || colors["Other"],
                'width': ele => sizeScale(ele.data('centrality')),
                'height': ele => sizeScale(ele.data('centrality')),
                'label': 'data(label)',
                'color': '#000',
                'font-size': ele => fontScale(ele.data('centrality')),
                'text-valign': 'center',
                'text-halign': 'center',
                'border-color': '#000',
                'border-width': 3
              }
            },
            {
              selector: 'edge',
              style: {
                'width': 1,
                'line-color': '#ccc',
                'curve-style': 'straight'
              }
            }
          ],
          layout: { name: 'preset' }
        });

        // Interactive Legend
        const legend = document.getElementById('legend');
        Object.keys(colors).forEach(type => {
          const label = document.createElement('label');
          label.style.marginRight = '10px';
          label.innerHTML = `<input type="checkbox" checked data-type="${type}"> <span style="color:${colors[type]}">${type}</span>`;
          legend.appendChild(label);
        });

        legend.querySelectorAll('input').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            const type = checkbox.getAttribute('data-type');
            const visible = checkbox.checked;
            cy.nodes().filter(n => n.data('type') === type).forEach(n => {
              n.style('display', visible ? 'element' : 'none');
            });
          });
        });

        // Popper Annotations for Groups
        const groupFiles = ['group1.txt', 'group2.txt', 'group3.txt', 'group4.txt', 'group5.txt', 'group6.txt'];
        groupFiles.forEach((file, idx) => {
          fetch(file)
            .then(res => res.text())
            .then(text => {
              const ids = text.trim().split(/\s+/);
              ids.forEach(id => {
                const node = cy.getElementById(id);
                if (node.nonempty()) {
                  const ref = node.popperRef();
                  const tooltip = document.createElement('div');
                  tooltip.classList.add('popper-box');
                  tooltip.innerText = `Group ${idx + 1}`;
                  document.body.appendChild(tooltip);
                  Popper.createPopper(ref, tooltip, {
                    placement: 'top',
                    modifiers: [
                      { name: 'offset', options: { offset: [0, 8] } }
                    ]
                  });
                }
              });
            });
        });

        window.cy = cy; // expose for debugging
      })
      .catch(err => {
        document.body.innerHTML = "<p style='color:red'>Error loading graph data.</p>";
        console.error(err);
      });
  </script>
</body>
</html>
