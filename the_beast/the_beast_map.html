<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>The Beast Transmedia Map</title>
  <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: sans-serif;
    }
    #cy {
      width: 100%;
      height: calc(100vh - 60px);
      display: block;
    }
    #legend-wrapper {
      height: 60px;
      background: #f4f4f4;
      border-top: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 1em;
      box-sizing: border-box;
    }
    #legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      cursor: pointer;
      margin-right: 10px;
      user-select: none;
    }
    .legend-color {
      width: 16px;
      height: 16px;
      margin-right: 6px;
      border: 1px solid #000;
    }
    .legend-item input[type=checkbox] {
      margin-right: 5px;
    }
    .legend-item.hidden {
      opacity: 0.4;
    }
    #recenter-btn {
      padding: 6px 12px;
      background: #0074D9;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 16px;
    }
    #recenter-btn:hover {
      background: #005fa3;
    }
    #switch {
      margin-left: 18px;
      margin-right: 12px;
    }
    #mode-label {
      font-weight: bold;
      font-size: 15px;
      margin-right: 10px;
      color: #444;
    }
    /* Tooltip styling */
    #node-tooltip {
      display: none;
      position: absolute;
      min-width: 240px;
      background: rgba(255,255,255,0.98);
      box-shadow: 0 8px 32px 0 #3335, 0 1.5px 8px #bbb9;
      border-radius: 13px;
      padding: 16px 18px;
      z-index: 99;
      pointer-events: auto;
      font-size: 1.1em;
      border: 1px solid #8882;
      color: #222;
      max-width: 400px;
      word-break: break-word;
      transition: left 0.1s, top 0.1s;
    }
  </style>
</head>
<body>

<div id="cy"></div>

<div id="legend-wrapper">
  <div style="display: flex; align-items: center;">
    <span id="mode-label">Color: Type</span>
    <label id="switch">
      <input type="checkbox" id="colorSwitch">
      Group coloring
    </label>
    <div id="legend"></div>
  </div>
  <button id="recenter-btn" onclick="cy.fit()">Recenter View</button>
</div>

<div id="node-tooltip"></div>

<script>
const typeColorMap = {
  "Email": "#FF00FF",
  "Event": "#FF0000",
  "Object": "#999999",
  "Photo": "#FF6666",
  "Post": "#FFFF00",
  "Puzzle": "#FF6600",
  "Sound": "#00FFCC",
  "Video": "#00FF00",
  "Webpage": "#3333FF",
  "Other": "#0074D9"
};

const groupColors = [
  "#cc2a36", "#3366cc", "#f47c3c", "#2ecca3", "#ad0bcc", "#e6d72a"
];
const groupFiles = [
  'group1.txt', 'group2.txt', 'group3.txt',
  'group4.txt', 'group5.txt', 'group6.txt'
];

let cy;
let groupMembership = {}; // node 'name'/id -> group idx
let colorMode = "type"; // or "group"
let activeFilters = {}; // {type/group idx: true/false}

function setNodeColors(mode) {
  cy.nodes().forEach(node => {
    // Should be visible? (legend-based filter)
    let show = true;
    if (mode === "type") {
      let t = node.data("type");
      show = activeFilters[t] !== false;
    } else {
      let groupIdx = groupMembership[node.data("name")];
      show = typeof groupIdx === "number" && activeFilters[groupIdx] !== false;
    }
    node.style("display", show ? "element" : "none");
    // Color and glow
    if (mode === "group") {
      let groupIdx = groupMembership[node.data("name")];
      if (typeof groupIdx === "number") {
        node.style("background-color", groupColors[groupIdx]);
        node.style("box-shadow", `0 0 80px 32px ${groupColors[groupIdx]}cc`);
        node.style("filter", `drop-shadow(0 0 64px ${groupColors[groupIdx]})`);
      } else {
        node.style("background-color", "#bbb");
        node.style("box-shadow", "none");
        node.style("filter", "none");
      }
    } else {
      const t = node.data("type");
      node.style("background-color", typeColorMap[t] || "#0074D9");
      node.style("box-shadow", "none");
      node.style("filter", "none");
    }
  });
  updateLegend(mode);
}

function updateLegend(mode) {
  const legend = document.getElementById("legend");
  legend.innerHTML = "";
  if (mode === "type") {
    Object.entries(typeColorMap).forEach(([type, color]) => {
      const item = document.createElement("label");
      item.className = "legend-item";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = activeFilters[type] !== false;
      checkbox.addEventListener("change", () => {
        activeFilters[type] = checkbox.checked;
        setNodeColors(colorMode);
      });
      const colorBox = document.createElement("div");
      colorBox.className = "legend-color";
      colorBox.style.backgroundColor = color;
      const label = document.createElement("span");
      label.textContent = type;
      item.appendChild(checkbox);
      item.appendChild(colorBox);
      item.appendChild(label);
      legend.appendChild(item);
    });
  } else {
    // group mode
    for (let i = 0; i < groupFiles.length; i++) {
      const item = document.createElement("label");
      item.className = "legend-item";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = activeFilters[i] !== false;
      checkbox.addEventListener("change", () => {
        activeFilters[i] = checkbox.checked;
        setNodeColors(colorMode);
      });
      const colorBox = document.createElement("div");
      colorBox.className = "legend-color";
      colorBox.style.backgroundColor = groupColors[i % groupColors.length];
      const label = document.createElement("span");
      label.textContent = `Group ${i+1}`;
      item.appendChild(checkbox);
      item.appendChild(colorBox);
      item.appendChild(label);
      legend.appendChild(item);
    }
  }
}

function assignGroupsToNodes(nodes, groupLists) {
  const membership = {};
  for (let g = 0; g < groupLists.length; g++) {
    groupLists[g].forEach(name => {
      membership[name] = g;
    });
  }
  return membership;
}

// List of fields to display in tooltip
const tooltipFields = [
  {key: "Label", label: "Label"},
  {key: "type", label: "Type"},
  {key: "Platform", label: "Platform"},
  {key: "Affiliation", label: "Affiliation"},
  {key: "outdegree", label: "Outdegree"},
  {key: "indegree", label: "Indegree"},
  {key: "BetweennessCentrality", label: "Betweenness Centrality"}
];

// Load group lists using "name" for matching
Promise.all(groupFiles.map(f =>
  fetch(f).then(res => res.text()).then(txt =>
    txt.split('\n').map(x => x.trim().replace(/^"|"$/g, '')).filter(Boolean)
  )
)).then(groupLists => {
  fetch("The_Beast_transmedia_map.cyjs")
    .then(res => res.json())
    .then(data => {
      const elements = data.elements;
      // Filter out FAN nodes
      const filteredNodes = elements.nodes.filter(n =>
        !(n.data.owner && n.data.owner.toUpperCase() === 'FAN')
      );
      // Map group membership using the "name" field
      groupMembership = assignGroupsToNodes(filteredNodes, groupLists);

      const nodeIds = new Set(filteredNodes.map(n => n.data.id));
      const filteredEdges = elements.edges.filter(e =>
        nodeIds.has(e.data.source) && nodeIds.has(e.data.target)
      );
      // Betweenness range
      const minBC = Math.min(...filteredNodes.map(n => parseFloat(n.data.BetweennessCentrality || 0)));
      const maxBC = Math.max(...filteredNodes.map(n => parseFloat(n.data.BetweennessCentrality || 0)));
      cy = cytoscape({
        container: document.getElementById('cy'),
        elements: {
          nodes: filteredNodes,
          edges: filteredEdges
        },
        layout: { name: 'preset' },
        style: [
          {
            selector: 'node',
            style: {
              'label': 'data(Label)',
              'background-color': ele => typeColorMap[ele.data('type')] || '#0074D9',
              'color': '#000000',
              'text-valign': 'center',
              'text-halign': 'center',
              'font-size': `mapData(BetweennessCentrality, ${minBC}, ${maxBC}, 30, 60)`,
              'width': `mapData(BetweennessCentrality, ${minBC}, ${maxBC}, 50, 500)`,
              'height': `mapData(BetweennessCentrality, ${minBC}, ${maxBC}, 50, 500)`,
              'border-width': 3,
              'border-color': '#000000'
            }
          },
          {
            selector: 'edge',
            style: {
              'width': 2,
              'line-color': '#ccc',
              'target-arrow-color': '#ccc',
              'target-arrow-shape': 'triangle'
            }
          }
        ]
      });

      // --- NODE TOOLTIP LOGIC ---
      const tooltip = document.getElementById("node-tooltip");
      function showNodeTooltip(node, evt) {
        let html = `<b style="font-size:1.16em;">${node.data("Label") || node.data("name")}</b><br><hr style="margin:6px 0;">`;
        tooltipFields.forEach(f => {
          let val = node.data(f.key);
          if (val !== undefined && f.key !== "Label") {
            html += `<b>${f.label}</b>: ${String(val).replaceAll("\n", "<br>")}<br>`;
          }
        });
        tooltip.innerHTML = html;
        tooltip.style.display = "block";
        // Position smartly: default right, but shift if would overflow
        let pos = node.renderedPosition();
        let cx = cy.container().getBoundingClientRect();
        let tooltipW = tooltip.offsetWidth || 260;
        let tooltipH = tooltip.offsetHeight || 160;
        let pageW = window.innerWidth;
        let pageH = window.innerHeight;
        // Default position
        let left = pos.x + cx.left + 20;
        let top = pos.y + cx.top - 10;
        // Adjust if would overflow right
        if (left + tooltipW > pageW - 20) left = pageW - tooltipW - 20;
        // Adjust if would overflow bottom
        if (top + tooltipH > pageH - 20) top = pageH - tooltipH - 20;
        // Adjust if would overflow top/left
        if (left < 5) left = 5;
        if (top < 5) top = 5;
        tooltip.style.left = left + "px";
        tooltip.style.top = top + "px";
      }
      function hideNodeTooltip() { tooltip.style.display = "none"; }
      cy.on('tap', 'node', function(evt) {
        showNodeTooltip(this, evt);
        evt.stopPropagation();
      });
      cy.on('tap', function(evt) {
        if (evt.target === cy) hideNodeTooltip();
      });
      cy.on('zoom pan', hideNodeTooltip);
      window.addEventListener('scroll', hideNodeTooltip);

      // UI: handle color scheme switch
      const switchEl = document.getElementById('colorSwitch');
      const modeLabel = document.getElementById('mode-label');
      switchEl.addEventListener('change', function() {
        colorMode = switchEl.checked ? "group" : "type";
        modeLabel.textContent = "Color: " + (colorMode === "type" ? "Type" : "Group");
        activeFilters = {};
        setNodeColors(colorMode);
      });

      setNodeColors("type");
      updateLegend("type");
    });
});
</script>
</body>
</html>
